most recently updated Sun, 07 Aug 2011

JsUnzip is a javascript library that can read and extract zip files.
The zip file here contains all the javascript code to read zip files, as
well as an accompanying html demonstration page.

The jsUnzip library does not depend on third-party Javascript UI
frameworks (prototype, jQuery, etc), but the demonstration uses jQuery.

JsUnzip works on IE7 and IE8, and FF3.6 and 4.0. I haven't tested it on
other browsers.  It works by reading a zip file from the server (without
violating the same origin policy), and then processing the binary
content of that file, within the javascript VM running in the browser.

=======================================================

About the Demonstration

This archive includes an HTML page that shows how to unzip within
Javascript.  It will run on any operating system, any browser. It must
be served from a web server, but it can be served from any sort of web
server, on any operating system.

To run the demonstration, unpack the zipfile into a directory that is
served by your web server.  You will get a set of files:

   ZipFile.htm
   Jsunzip-Readme.txt  (this file)
   License.txt
   script/ZipFile.complete.js
   script/RawXmlAsHtml.js
   style/RawXmlAsHtml.css
   style/RawXmlAsHtml.xslt
   zips/...  (various)


In the zips subdirectory are various files, some of them vanilla ZIP
files, and some of them "other" file formats that use zip files,
including an .epub file, an XLSX (MS-Excel 2007 format) and an XPS
file. All of these are ZIP formats, though they have different
extensions.

To successfully run the demo, you will require internet access, because
the page downloads jQuery and jQuery UI from Google.

Be sure to set the MIME types on your Web server for the downloadable
files. On many servers, .EPUB and .XLSX may not be mapped to any
mime-type.  These are the correct values:

   .epub
   application/x-zip-compressed

   .xslx
   application/vnd.openxmlformats-officedocument.spreadsheetml.sheet

   .xps
   application/vnd.ms-xpsdocument



After setting up the web directory, browse to zipfile.htm . Select a
file to unpack from the dropdown list.  Click "Load".

The browser will load the selected document from your web server. It
will then unpack and de-compress the zipfile, and display the contents
on the right hand side of the browser window.

Obviously this is just a demonstration.  Typically after unpacking the
browser page would do something more useful with the content, for
example display a formatted version of an epub file for viewing.

Reading larger files takes more time. In a previous version of this
demonstration, it took MUCH more time - but I've made an enhancement to
speed things up nicely.

Because the Javascript library uses asynchronous unpacking, even though
it takes "a long time", the browser shouldn't complain about a
long-running script (in IE, this is a alert box saying "Stop running
this script?  A script on this page is causing Internet Explorer to run
slowly.")  Even though you should see no warning, the script will run
for a few seconds, and it may consume all CPU on your desktop machine.


=======================================================

The JzUnzip class library

The main class in the library is ZipFile. To read a zip file, call new
ZipFile(), passing the URL for the zip archive, and a function to call
when the zipfile has been successfully read.  This is an asynchronous
callback. Like this:

    var doneReading = function(zip){ ... };
    var zipFile = new ZipFile(url, doneReading, verbosity);

The verbosity argument is optional.

ZipFile exposes these properties:

  - entries - an array of ZipEntry objects
  - entryNames - an array of strings, names of entries in the ZipFile
  - status - an array of status messages generated by the ZipFile
  - binFile - the property used internally to read the binary file
  - verbose - an integer. With verbose > 0, status messages will get
              put into the status property.

In the doneReading function you can do what you like with the in the
zipFile. For example, you might first want to verify that the file was
read successfully.  Any WARNING or ERROR message will be noted in the
status array. For example, if the URL returns a 403 or 404, it will be
noted here.

    var doneReading = function(zip){
        for (var i=0; i<zip.status.length;  i++) {
            var msg = zip.status[i];
            if (msg.indexOf("ERROR") !== 0) {
               ....
            }
        }
    };

You then might want to display the names of the entries:

    var doneReading = function(zip){
           ....
        for (var i=0; i<zip.entries.length;  i++) {
            var entry = zip.entries[i];
            var entryInfo = "<li>" + entry.name + "</li>";
            $("#zipcontents").append(entryInfo);
        }
    };


...or extract them:

    var extractCb = function(entry, entryContent) {
        // entry is a ZipEntry.
        // entryContent is either a string or a byte array.
        ....
    };

    var doneReading = function(zip){
           ....
        for (var i=0; i<zip.entries.length;  i++) {
            var entry = zip.entries[i];
            // extract asynchronously
            entry.extract(extractCb);
        }
    }

Each element in zip.entries is a ZipEntry object, containing various
properties for the entry:

  - name - the name of the entry, including any path.
  - crc32 - the crc32 for the entry
  - lastModified - a Date, the last modified date and time for the entry
  - uncompressedSize - the size of the entry when uncompressed
  - compressedSize - the size of the entry when compressed
  - and others...

The ZipEntry class also exposes several methods for reading the
decompressed content:

  - extract()
  - openTextReader()
  - openBinaryReader()
  - verifyCrc()

extract()

    The extract() method accepts two arguments, a callback function,
    and a boolean. Both are optional.

    If you simply call entry.extract(), the library will attempt to
    extract the entry as a text string, synchronously.  The extracted
    content is the return value of the function call.

    Synchronous extraction of text content is often what you want, but
    sometimes you don't.  Extracting an entry can take a looooong
    time. Five seconds or so, for entries that are 30k. (DEFLATE in
    Javascript is very slow.)  Therefore ZipEntry allows asynchronous
    extraction, in addition to the simple synchronous extraction
    described above.  To use async extraction, pass a callback argument,
    and it will be invoked with the result of the extraction,
    asynchronously, after the read has succeeded.

    The callback itself should accept two arguments: the entry object
    and the entryContent. On successful extraction, the latter is either
    a string or an array of bytes, depending on whether the entry is a
    text file or a binary file. Within the callback you can get the
    name, date, size, and so on, via the ZipEntry properties on the
    entry argument.

    If the CRC check fails, entryContent will be an Error object. Check
    for it like this:

         if ((typeof entryContent.description == "string") &&
             (entryContent.name == "Error")) {
             ... the CRC check failed,
                 or some other error occurred...
         }


    The second argument to ZipEntry.extract() is a boolean, that
    indicates whether to treat the entry content as a text file or a
    binary file.  If true, the extracted content is returned as a
    string, when using the synchronous model; when using the
    asynchronous model, entryContent will be a string. Otherwise - when
    the boolean is false - the extracted content is returned as an array
    of bytes in the synchronous model; in the async model (when using a
    callback), entryContent will be an array of bytes.

    If you don't pass the second argument, ZipFile uses a heuristic to
    guess the type of the entry, based on the file extension. Entries
    with names that end in .txt, .htm, .xml and so on, are treated as
    text. Entries that end in .zip and .bin are treated as binary. When
    in doubt, the hueristic leans toward binary.

    The only real difference between text and binary entries is that,
    upon calling ZipEntry.extract(), the code will attempt to decode the
    content for text entries, with a TextDecoder.

    If you use a for-loop and call extract() with a callback for each
    entry, you are creating a thread to extract each entry. As the
    number of entries grows, the number of active threads also grows. If
    you have a zip file with 25 entries, you will implicitly create 25
    threads this way.

    Also, using asynchronous extraction in a loop, the callbacks will
    fire in a different order than the one in which you called
    extract().


openTextReader()
openBinaryReader()

    These methods open a reader on the entry stored in the zip file. Use
    one for binary content, the other for text content.  The text
    version allows you to specify a decoder - for UTF8, UTF16, or ASCII
    encoding of content (See the classes in JSIO.TextDecoder).
    If you specify nothing, UTF8 is used.

    In each case, the return value is a "reader" object that allows the
    application to read data.

    If you call openTextReader(), the methods exposed on the return
    value are:

      - readChar()           = read 1 char. Return null at EOF.
      - read(n)              = read n chars, return a string.
      - readLine()           = read one line of data (to \n)
      - unreadChar(ch)       = unread one char
      - readToEnd()          = read all remaining data in the
      -                        reader; return a string.
      - beginReadToEnd(cb)   = asynchronously read all data.

    If you call openBinaryReader(), the methods on the return
    value are:

      - readByte()           = read 1 byte; returns null when
                               EOF is reached.
      - readToEnd()          = returns an array of all remaining bytes
                               available.
      - beginReadToEnd(cb)   = async version of the above.
      - readBytes(n)         = returns an array of the next n bytes
                               available from the source.
      - beginReadBytes(n,cb) = async version of the above


    When you read content with these methods, the CRC32 of
    the stored zip entry is not automatically verified.

        The zip format stores a CRC32 of the original content for each
        entry in the zip file. Normally libraries that read zip files
        verify the CRC against the decompressed content.

    If you use a reader, the ZipEntry keeps a running calculation of the
    CRC32, for all the data you've read for the entry.  When the last
    byte is read, you should call ZipEntry.verifyCrc() to check that the
    CRC is valid.

    The extract() method automatically verifies the CRC, and emits a
    status message in the status array if it does not match.


verifyCrc()

    Verifies the CRC32 of the ZipEntry content. The result is valid only
    after reading all content for the entry, via readToEnd() or
    beginReadToEnd(), or by calling readChar() or readByte() (whichever
    is appropriate) until EOF is reached.


=======================================================

Some interesting notes on the implementation:

 - The ZipFile "class" depends on a set of lower-level libraries
   implemented in javascript, for downloading binary content, reading
   and inflating the stream containing that content, and calculating
   CRCs. All of those libraries are consolidated into
   Zipfile.complete.js. You may find them useful separately.

 - the ZipFile class performs a GET on a URL referencing a zipfile. To
   use the class within a browser, the URL must not violate the
   same-origin policy. In other words you need to download the zip file
   from the same origin server that provided the web page.

 - There's currently no way to retrieve the zip file through
   POST. If you want this, you'd need to extend the BinaryUrlStream
   class.

 - the contents of the zip archive are held in memory in the javascript
   engine managed by the browser. If you try reading a 1mb zipfile, it
   is held in memory in its entirety.  If you call extract(), then both
   the compressed and uncompressed version of that particular entry is
   held in memory. Be aware. In your own applications that use this
   library, you may wish to actively reclaim memory.  You can do that by
   calling "delete" on ZipFile instances you no longer need, in your
   javascript code.

 - At no time during execution of the demonstration does the Javascript
   code ever create any files explicitly on your computer when you load
   this page. As you may know, it is not possible to do this within
   Javascript running in a browser page. The zipfile and all of the
   files "extracted" from it, are all retained in memory in the browser.
   For large zip files, this can take up lots and lots of memory, so be
   careful.

 - The demonstration uses a stylesheet in the browser (via javascript)
   to render XML as HTML - see RawXmlAsHtml.xslt in the style directory.



=======================================================

Limitations

The classic zip format is well-documented and understood. The JsUnzip
library supports the basic format, and can read most zip files.  The
library does not support the more advanced zip features, such as:

  - encrypted archives, password-protected archives
  - extra fields, which might contain high-resolution timestamps,
    and other metadata.
  - zip64 archives
  - any compression method other than DEFLATE
  - spanned or split archives
  - "bit 3" encoding of zip entries

For more on what each of these things is, you'll have to read the ZIP
specification from PKWare.



Dino Chiesa
May 2010
